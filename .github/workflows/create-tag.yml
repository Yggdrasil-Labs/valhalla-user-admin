name: Create Tag

on:
  # 监听 release-please 工作流的完成
  workflow_run:
    workflows: ["Release Please"]
    types:
      - completed
    branches:
      - main
  # 允许手动触发以修复失败的 tag
  workflow_dispatch:

permissions:
  contents: write

jobs:
  check-release-pr-merged:
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success'
    permissions:
      contents: read
      pull-requests: read
    outputs:
      is_release_pr: ${{ steps.check.outputs.is_release_pr }}
      merge_commit_sha: ${{ steps.check.outputs.merge_commit_sha }}
    steps:
      - name: Check if release PR was merged
        id: check
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            // 获取触发此工作流的 release-please 工作流运行信息
            const workflowRun = context.payload.workflow_run;
            console.log(`Release Please workflow run: ${workflowRun.id}`);
            console.log(`Conclusion: ${workflowRun.conclusion}`);
            console.log(`Event: ${workflowRun.event}`);
            console.log(`Head branch: ${workflowRun.head_branch}`);
            console.log(`Head SHA: ${workflowRun.head_sha}`);

            // 直接查找与触发 commit 关联的 PR
            // 这比列出最近 PR 并检查时间戳更可靠，也避免了竞态条件
            const { data: prs } = await github.rest.repos.listPullRequestsAssociatedWithCommit({
              owner: context.repo.owner,
              repo: context.repo.repo,
              commit_sha: workflowRun.head_sha,
            });

            console.log(`Found ${prs.length} associated PRs`);

            const releasePR = prs.find(pr => {
              // 确保 PR 已合并
              if (!pr.merged_at) return false;

              // 支持两种分支格式：
              // 1. simple release type: release-please--branches--main
              // 2. node release type: release-please--branches--main--components--*
              const isReleaseBranch = pr.head.ref.startsWith('release-please--branches--main');

              // 兼容 Release Please 默认标题，同时避免误判包含 "action-gh-release" 等依赖升级 PR
              const title = pr.title || '';
              const lowerTitle = title.toLowerCase();

              const isReleaseTitle =
                // 标准 release-please 标题：chore(main): release x.y.z 或 chore(release): vx.y.z
                /chore\((main|release)\):/i.test(title) ||
                // 其他以 release 开头的标题：如 "release 1.2.3" / "Release: 1.2.3"
                lowerTitle.startsWith('release ') ||
                lowerTitle.startsWith('release:') ||
                lowerTitle.startsWith('release-');

              return isReleaseBranch || isReleaseTitle;
            });

            if (releasePR) {
              console.log(`✓ Found associated release PR: #${releasePR.number}`);
              console.log(`  Title: ${releasePR.title}`);
              console.log(`  Head ref: ${releasePR.head.ref}`);
              console.log(`  Merged at: ${releasePR.merged_at}`);
              console.log(`  Merge commit SHA: ${releasePR.merge_commit_sha}`);

              core.setOutput('is_release_pr', 'true');
              // 如果有关联 PR，使用其 merge_commit_sha；否则回退到 workflow_run.head_sha
              core.setOutput('merge_commit_sha', releasePR.merge_commit_sha || workflowRun.head_sha);
            } else {
              console.log('ℹ️  No associated release PR found for this commit');
              console.log('   This workflow will be skipped');
              core.setOutput('is_release_pr', 'false');
              core.setOutput('merge_commit_sha', '');
            }

  create-and-push-tag:
    runs-on: ubuntu-latest
    needs: [check-release-pr-merged]
    # 如果是手动触发，或者是自动触发且检测到是 release PR，则执行
    if: |
      always() &&
      (github.event_name == 'workflow_dispatch' || needs.check-release-pr-merged.outputs.is_release_pr == 'true')
    permissions:
      contents: write
    steps:
      - name: Checkout code
        uses: actions/checkout@de0fac2e4500dabe0009e67214ff5f5447ce83dd # v6.0.2
        with:
          fetch-depth: 1
          # checkout 到合并后的 commit（优先使用 merge_commit_sha，否则使用 main 分支）
          ref: ${{ (needs.check-release-pr-merged.outputs.merge_commit_sha != '' && needs.check-release-pr-merged.outputs.merge_commit_sha) || 'main' }}
          # 关键：不持久化 GITHUB_TOKEN，避免它干扰后续使用 RELEASE_TOKEN 的推送
          persist-credentials: false

      - name: Extract version from manifest
        id: get_version
        run: |
          echo "=== Extracting Version ==="
          echo "Current commit SHA: $(git rev-parse HEAD)"
          echo "Current branch: $(git branch --show-current)"

          # 优先从 .release-please-manifest.json 中提取版本号（Release Please 的权威版本源）
          if [ -f ".github/.release-please-manifest.json" ]; then
            echo "Manifest file exists, reading..."
            cat .github/.release-please-manifest.json
            VERSION=$(jq -r '.["."]' .github/.release-please-manifest.json 2>/dev/null || echo "")
            if [ -n "$VERSION" ] && [ "$VERSION" != "null" ]; then
              echo "✓ Extracted version from manifest: $VERSION"
            else
              echo "⚠ Manifest exists but version is empty or null: '$VERSION'"
            fi
          else
            echo "⚠ Manifest file not found at .github/.release-please-manifest.json"
          fi

          # 如果从 manifest 获取失败，尝试从 CHANGELOG.md 中提取最新版本
          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            if [ -f "CHANGELOG.md" ]; then
              # 从 CHANGELOG 中提取第一个版本号（格式：## [1.1.0] 或 ## 1.1.0）
              VERSION=$(grep -m 1 -E '^## \[?[0-9]+\.[0-9]+\.[0-9]+\]?' CHANGELOG.md | sed -E 's/^## \[?([0-9]+\.[0-9]+\.[0-9]+)\]?.*/\1/' | head -1)
              if [ -n "$VERSION" ]; then
                echo "✓ Extracted version from CHANGELOG: $VERSION"
              fi
            fi
          fi

          # 如果还是失败，回退到从 package.json 中提取
          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            if [ -f "package.json" ]; then
              VERSION=$(jq -r '.version' package.json 2>/dev/null || echo "")
              if [ -n "$VERSION" ] && [ "$VERSION" != "null" ]; then
                echo "✓ Extracted version from package.json: $VERSION"
              fi
            fi
          fi

          if [ -z "$VERSION" ] || [ "$VERSION" == "null" ]; then
            echo "Error: Could not extract version from manifest, CHANGELOG, or package.json"
            echo "Manifest content:"
            cat .github/.release-please-manifest.json 2>/dev/null || echo "Manifest not found"
            echo "CHANGELOG first 10 lines:"
            head -10 CHANGELOG.md 2>/dev/null || echo "CHANGELOG not found"
            echo "package.json version:"
            jq '.version' package.json 2>/dev/null || echo "package.json not found"
            exit 1
          fi

          # 生成 tag 名称（确保以 v 开头）
          if [[ "$VERSION" =~ ^v ]]; then
            TAG_NAME="$VERSION"
          else
            TAG_NAME="v$VERSION"
          fi

          echo "version=$VERSION" >> $GITHUB_OUTPUT
          echo "tag_name=$TAG_NAME" >> $GITHUB_OUTPUT
          echo "Final version: $VERSION"
          echo "Final tag name: $TAG_NAME"

      - name: Create and push tag
        env:
          TAG_NAME: ${{ steps.get_version.outputs.tag_name }}
          VERSION: ${{ steps.get_version.outputs.version }}
          # 使用 RELEASE_TOKEN (PAT) 来推送 tag，这样能自动触发 release 工作流
          RELEASE_TOKEN: ${{ secrets.RELEASE_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
        run: |
          echo "=== Creating Tag for Release ==="
          echo "Version: $VERSION"
          echo "Tag name: $TAG_NAME"
          echo "================================="

          if [ -z "$TAG_NAME" ] || [ -z "$VERSION" ]; then
            echo "Error: TAG_NAME or VERSION is empty"
            echo "TAG_NAME: $TAG_NAME"
            echo "VERSION: $VERSION"
            exit 1
          fi

          # 确保 tag 名称以 'v' 开头
          if [[ ! "$TAG_NAME" =~ ^v ]]; then
            TAG_NAME="v$TAG_NAME"
            echo "Adjusted tag name to: $TAG_NAME"
          fi

          # 获取当前 commit SHA
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "Current commit SHA: $COMMIT_SHA"

          # 检查 tag 是否已存在
          if git rev-parse "$TAG_NAME" >/dev/null 2>&1; then
            EXISTING_SHA=$(git rev-parse "$TAG_NAME")
            if [ "$EXISTING_SHA" == "$COMMIT_SHA" ]; then
              echo "✓ Tag $TAG_NAME already exists and points to the same commit, skipping creation"
            else
              echo "⚠ Warning: Tag $TAG_NAME exists but points to different commit"
              echo "  Existing: $EXISTING_SHA"
              echo "  Current:  $COMMIT_SHA"
              exit 1
            fi
          else
            # 创建 tag（指向当前 HEAD，即合并后的 commit）
            echo "Creating annotated tag: $TAG_NAME"
            git config user.name "github-actions[bot]"
            git config user.email "github-actions[bot]@users.noreply.github.com"
            git tag -a "$TAG_NAME" -m "Release $VERSION"

            # 使用 RELEASE_TOKEN (PAT) 推送 tag，这样能自动触发 release 工作流
            # 如果 RELEASE_TOKEN 不存在，回退到 GITHUB_TOKEN（但不会触发工作流）
            if [ -n "$RELEASE_TOKEN" ] && [ "$RELEASE_TOKEN" != "" ]; then
              echo "Using RELEASE_TOKEN to push tag (will trigger Release workflow automatically)"

              # 直接构造带 Token 的 URL 进行推送，这是最稳健的方式
              # 避免依赖 git config 清理和 credential helper 可能导致的回退问题
              GIT_API_URL="https://x-access-token:${RELEASE_TOKEN}@github.com/${GITHUB_REPOSITORY}.git"

              # 推送 tag
              echo "Pushing tag $TAG_NAME..."
              if git push "$GIT_API_URL" "$TAG_NAME"; then
                echo "✓ Successfully created and pushed tag: $TAG_NAME using RELEASE_TOKEN"
                echo "✓ This should trigger the Release Build workflow automatically"
              else
                echo "❌ Failed to push tag"
                exit 1
              fi
            else
              echo "⚠️  RELEASE_TOKEN not found, using GITHUB_TOKEN (will NOT trigger Release Build workflow)"
              echo "   Please configure RELEASE_TOKEN secret to enable automatic workflow triggering"
              git push origin "$TAG_NAME"
              echo "✓ Tag pushed, but Release Build workflow will NOT be triggered automatically"
              echo "   You need to manually trigger it or configure RELEASE_TOKEN secret"
            fi
          fi
